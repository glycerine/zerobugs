#ifndef STACK_TRACE_H__854BE000_3C78_4715_854E_BE27414892AF
#define STACK_TRACE_H__854BE000_3C78_4715_854E_BE27414892AF
//
// $Id: stack_trace.h 714 2010-10-17 10:03:52Z root $
//
// -------------------------------------------------------------------------
// This file is part of ZeroBugs, Copyright (c) 2010 Cristian L. Vlasceanu
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
// -------------------------------------------------------------------------
//
// Classes: FrameImpl, StackTraceImpl
//
#include <cassert>
#include <map>
#include <vector>
#include "zdk/weak_ptr.h"
#include "zdk/zero.h"
#include "zdk/zobject_impl.h"
#include "dharma/config.h"
#include "dharma/hash_map.h"
#include "dharma/object_manager.h"

class StackTraceImpl;


CLASS FrameImpl : public ZObjectImpl<Frame>
{
    //
    // for set_user_object(), get_user_object()
    //
    typedef ext::hash_map<std::string, RefPtr<ZObject> > ObjectMap;

public:
    FrameImpl(StackTraceImpl&, const Thread&);

    /**
     * The userObj_ map is transferred to the copy
     */
    FrameImpl(/* const */ FrameImpl&, size_t index);

    virtual ~FrameImpl() throw();

    virtual addr_t program_count() const;

    virtual addr_t stack_pointer() const;

    virtual addr_t frame_pointer() const;

    virtual Symbol* function(Symbol* = NULL) const;

    virtual size_t index() const { return index_; }

    virtual void set_user_object(const char* key, ZObject*);

    virtual ZObject* get_user_object(const char* key) const;

    virtual addr_t real_program_count() const
    { return realPC_ ? realPC_ : pc_; }

    virtual bool is_signal_handler() const
    { return sigHandler_; }

    bool skip() const { return skip_; }
    void set_skip(bool flag) { skip_ = flag; }

    //NOTE: setters are not exposed in the base-class interface

    void set_program_count(addr_t pc);

    void set_stack_pointer(addr_t sp) { sp_ = sp; }

    void set_frame_pointer(addr_t fp) { fp_ = fp; }

    void set_real_program_count(addr_t realPC)
    { realPC_ = realPC; }

    void set_signal_handler(bool isHandler = true)
    { sigHandler_ = isHandler; }


    // @todo
    bool is_from_frame_handler() const
    { return false; }

private:
    FrameImpl(const FrameImpl&);    // non-copyable
    FrameImpl& operator=(const FrameImpl&);

    WeakPtr<StackTraceImpl> trace_; // owner of this frame
    mutable RefPtr<Symbol> sym_;

    addr_t pc_;
    addr_t sp_;
    addr_t fp_;
    addr_t realPC_;
    size_t index_;

    bool sigHandler_ : 1;
    bool skip_ : 1;

    ObjectMap userObj_;
};



CLASS StackTraceImpl : public ZObjectImpl<StackTrace>
{
public:
    typedef std::vector<RefPtr<FrameImpl> > FrameList;

    BEGIN_INTERFACE_MAP(StackTraceImpl)
        INTERFACE_ENTRY(StackTrace)
    END_INTERFACE_MAP()

    explicit StackTraceImpl(const Thread&);

    virtual ~StackTraceImpl() throw();

    virtual size_t size() const;

    virtual Frame* frame(size_t index) const;

    virtual void select_frame(size_t index);

    virtual Frame* selection() const;

    bool is_complete() const { return complete_ || unwinding_; }
    bool is_unwinding() const { return unwinding_; }

    RefPtr<Thread> thread() const { return thread_.ref_ptr(); }

    /**
     * Check for C functions prologue.
     */
    static bool check_prologue(const Thread&, const Frame&);

    /**
     * Populate the stack. If the bottom is reached before
     * maxDepth, set the complete_ flag, which will subsequently
     * be returned by is_complete().
     */
    void unwind(const Thread&, size_t maxDepth, const StackTrace* old = NULL);

    static bool use_frame_handlers();

private:
    // deprecated
    /**
     * 386 only: check for corrupted stack, calls recover_corrupted
     * @return true if corruption is detected
     */
    //bool verify_recover(const Thread&, const Frame&);

    // deprecated
    /**
     * Attempt to recover a corrupted stack by walking it
     * from bottom to top. Uses back-tracking to back away
     * from spurious frame pointers.
     * @note Not supported on x86_64, because frame pointers
     * are optional on the AMD64.
     */
    // void recover_corrupted(const Thread&);

    /**
     * Add the topmost frame, which corresponds to the current
     * program counter.
     * @return true if the unwinding may continue
     */
    bool unwind_begin(const Thread&, FrameImpl&, size_t maxDepth);

    bool unwind_frame(const Thread&, FrameImpl&);

    /**
     * Delegate to the frame handlers to get the next stack frame.
     * A frame handler may construct the next frame from the stack
     * unwind info generated by the compiler (.debug_frame)
     * or the exception handling info (.eh_frame).
     */
    RefPtr<Frame> unwind_frame_handlers(const Thread&, Frame&);

    void copy_symbols(const StackTrace&);

    /**
     * create and return a copy of the current stack trace
     */
    StackTrace* copy() const;

    size_t frame_handler_frame_count() const
    {
        return frameHandlerCount_;
    }

private:
    WeakPtr<Thread> thread_;
    bool            complete_;
    bool            unwinding_; // unwinding in progress?
    FrameList       frames_;
    size_t          sel_; // index of currently selected frame
    size_t          frameHandlerCount_;
#ifdef __PPC__
    RefPtr<FrameImpl> signalFrame_;
#endif
};


//
// utility functions
//
void ZDK_LOCAL stack_check_max_depth(size_t& depth);

void inline ZDK_LOCAL set_program_count(FrameImpl& f, reg_t pc)
{
    if (pc != f.program_count())
    {
        f.set_program_count(pc);
    }
}
#endif // STACK_TRACE_H__854BE000_3C78_4715_854E_BE27414892AF

// vim: tabstop=4:softtabstop=4:expandtab:shiftwidth=4
