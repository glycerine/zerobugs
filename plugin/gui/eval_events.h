#ifndef EVAL_EVENTS_H__ADBCE634_3C71_4E3A_8C83_02AF0D176CB9
#define EVAL_EVENTS_H__ADBCE634_3C71_4E3A_8C83_02AF0D176CB9
//
// $Id: eval_events.h 720 2010-10-28 06:37:54Z root $
//
// -------------------------------------------------------------------------
// This file is part of ZeroBugs, Copyright (c) 2010 Cristian L. Vlasceanu
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
// -------------------------------------------------------------------------
//
#include <string>
#include "zdk/debug_sym.h"
#include "zdk/export.h"
#include "zdk/expr.h"
#include "zdk/observer_impl.h"
#include "zdk/platform.h"
#include "zdk/ref_ptr.h"
#include "gtkmm/base.h"
#include "gtkmm/signal.h"



template<typename T, typename M = Mutex>
class ZDK_LOCAL SignalProxy
{
    boost::shared_ptr<Lock<M> > lock_;
    T& s_;

public:
    SignalProxy(T& s, M& mx) : lock_(new Lock<M>(mx)), s_(s)
    { }

    T* operator-> () { return &s_; }
};


/**
 * Observes events generated by the interpreter when
 * expressions are being evaluated.
 */
class ZDK_LOCAL EvalEvents
    : public SubjectImpl<ExprEvents>
    , public Gtk::Base // needed in Gtkmm 1.2
{
    Mutex           mutex_;
    bool            active_;
    RefPtr<Thread>  thread_;
    addr_t          addr_;
    RefPtr<ZObject> mixin_;

BEGIN_INTERFACE_MAP(EvalEvents)
    INTERFACE_ENTRY_INHERIT(SubjectImpl<ExprEvents>)
    INTERFACE_ENTRY_DELEGATE(mixin_)
END_INTERFACE_MAP()

    template<typename T> SignalProxy<T> wrap(T& s)
    {
        return SignalProxy<T>(s, mutex_);
    }

    SigC::Signal1<void, const Variant&> sig_done;
    SigC::Signal1<bool, std::string> sig_error;
    SigC::Signal1<bool, std::string> sig_warning;
    SigC::Signal3<void, std::string, bool*, const char*> sig_confirm;
    SigC::Signal0<void> sig_deactivate;

public:
    SignalProxy<SigC::Signal1<void, const Variant&> > signal_done()
    { return wrap(sig_done); }

    SignalProxy<SigC::Signal1<bool, std::string> > signal_error()
    { return wrap(sig_error); }

    SignalProxy<SigC::Signal1<bool, std::string> > signal_warning()
    { return wrap(sig_warning); }

    SignalProxy<SigC::Signal3<void, std::string, bool*, const char*> > signal_confirm()
    { return wrap(sig_confirm); }

    SignalProxy<SigC::Signal0<void> > signal_deactivate()
    { return wrap(sig_deactivate); }

    static RefPtr<EvalEvents> create(Thread* thread, ZObject* mixin = 0)
    { return new EvalEvents(thread, mixin); }

    void activate()
    {
        Lock<Mutex> lock(mutex_);
        active_ = true;
    }
    void deactivate()
    {
        Lock<Mutex> lock(mutex_);
        active_ = false;
        sig_deactivate.emit();
    }

    virtual ~EvalEvents() throw();

    Mutex& mutex() { return mutex_; }

protected:
    explicit EvalEvents(Thread* thread, ZObject* mixin)
        : active_(true)
        , thread_(thread)
        , addr_(0)
        , mixin_(mixin)
    { }

    EvalEvents(const EvalEvents& other)
        : active_(other.active_)
        , thread_(other.thread_)
        , addr_(other.addr_)
        , mixin_(other.mixin_)
    #ifdef GTKMM_2
        , sig_done(other.sig_done)
        , sig_error(other.sig_error)
        , sig_warning(other.sig_warning)
        , sig_confirm(other.sig_confirm)
    #endif
    { }

    bool on_done(Variant*, bool*, DebugSymbolEvents*);

    void on_error(const char*);

    void on_warning(const char*);

    bool on_event(Thread*, addr_t);

    void on_call(addr_t addr, Symbol* symbol);

    ExprEvents* clone() const { return new EvalEvents(*this); }

};

#endif // EVAL_EVENTS_H__ADBCE634_3C71_4E3A_8C83_02AF0D176CB9
// vim: tabstop=4:softtabstop=4:expandtab:shiftwidth=4
